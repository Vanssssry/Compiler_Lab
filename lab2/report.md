<center><b><font size = 10>算术表达式语法分析器实验

<center><b> 姓名：吕文禧  &nbsp &nbsp &nbsp &nbsp 学号：19335151
# 实验要求

>### 实验描述
>
>* 算术表达式语法分析器的设计与实现
>
>### 实验要求
>
>* 使用LL(1)分析法和LR分析法设计实现算术表达式的语法分析器
>
>* 算数表达式至少支持加减乘除以及括号操作，即（+，-，*，/，（））。
>
>### 提交内容
>
> 	1. 实验报告，报告内容必须包含：
>     * 算术表达式所依据的文法；
>     * LL(1)和LR分析法所使用的分析表，以及简要分析；
>     * 程序执行流程；
>     * 程序运行结果展示。
> 	2. 语法分析源程序：source.c（源程序包）
> 	3. 可执行文件
> 	4. 程序测试文件：test.txt（实验输入，将测试案例写入程序的可没有此项）



# 实验思路

## 功能设计

> 本次实验要求设计一个可以识别算术表达式语法的语法分析器，对于语法正确的算术表达式，返回分析正确，若算术表达式中有语法错误则需要返回错误分析报告，算数表达式至少支持加减乘除以及括号操作，即（+，-，*，/，（））。

​	对于本次实验，设计了一个基本满足C语言算术表达式的语法分析器，支持负数、自增、自减 (e.g. : i++, ++i, --i, i--) 运算操作的语法，基本全部的二元运算符以及括号操作。对于以下语法，能够正确判断表达式中有无语法错误，并且能够准确定位错误可能发生的地方。
$$
E \to T\ |\ E\omega_0T\\
T \to F\ |\ T\omega_1F\\
F \to I\ |\ (E)
$$
​	实验所设计的语法分析器以词法分析器作为上游，将词法分析器解析得到的token序列作为输入，分析token序列中有无不合上述语法的错误。只对算术表达式语法正确性进行分析，不对表达式语义是否符合逻辑负责。



## LL(1)设计

### 文法修改

由于算术表达式的原文法存在左递归，不属于LL1文法，需要修改得到以下LL1文法：
$$
E \to TE_1\ \ \ (1)\\ 
E_1 \to \omega_0TE_1\ (2)\ |\ \varepsilon \ (3)\\
T \to FT_1\ \ \ (4) \\ 
T_1\to  \omega_1FT_1\ (5)\ |\ \varepsilon \ (6)\\
F \to I\ (7) \ |\ (E)\ (8)
$$
得到LL1文法后，求得每个产生式的 select 集， 以获取LL1分析表。

| 产生式 | select集    |
| ------ | ----------- |
| 1      | {I，( }     |
| 2      | {ω0}        |
| 3      | { ) , #}    |
| 4      | {I，( }     |
| 5      | {ω1}        |
| 6      | {ω0, ) , #} |
| 7      | {I}         |
| 8      | { ( }       |

### LL1分析表

|       |  I   |  ω0  |  ω1  |  （  |  ）  |  #   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|  $E$  |  1   |      |      |  1   |      |      |
| $E_1$ |      |  2   |      |      |  3   |  3   |
|  $T$  |  4   |      |      |  4   |      |      |
| $T_1$ |      |  6   |  5   |      |  6   |  6   |
|  $F$  |  7   |      |      |  8   |      |      |

### 分析流程

对于LL1的语法分析器，需要一个分析栈一张分析表，一开始向栈内压入#E作为起始状态。开始时读入一个token，检查栈顶元素，若栈顶元素为非终结符Vn，则从LL1分析表中查找对应产生式的右部，若存在则逆序压入栈中，继续查看下一个栈顶元素而不移进字符，若该表项为空则返回错误信息；若栈顶元素为终结符Vt，则与当前移进的字符检查匹配，若不匹配则返回错误信息，若匹配则继续移进字符。重复上述步骤直至出现错误或者匹配到终结符`#`。

语法分析器的程序逻辑如下：

```flow
st=>start: Begin
cond1=>condition: x = w
cond2=>condition: x in VT
cond3=>condition: x in VN
cond4=>condition: W = $
cond5=>condition: IsEmpty?

op1=>operation: push($), push(E)
op2=>operation: next(w)
op3=>operation: pop(x)
op4=>operation: 查LL(1)分析表
op5=>operation: push(i)
op6=>operation: err
end=>end: end

st->op1->op2->op3->cond2(no)->cond3(yes)->op4->cond5(yes,left)->op6
op4->cond5(no)->op5->op3
op3->cond2(yes)->cond1(yes,right)->op2
cond2(yes)->cond1(no,bottom)->op6
cond2(no)->cond3(no)->cond4(yes)->end
cond4(no)->op6
```



### 负数处理

在LL1分析中处理负数



## LR(0)设计

### DFA设计



### LR分析表



### 分析流程



### 负数处理



# 具体实现

## LL(1)实现





## LR(0)实现





# 实验结果

## LL(1)结果

### 错误处理



### 正确性分析



## LR(0)结果

### 错误处理



### 正确性分析





# 实验心得

​	
