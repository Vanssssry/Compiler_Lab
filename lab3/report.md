<center><b><font size = 10>算术表达式语义分析器实验

<center><b> 姓名：吕文禧  &nbsp &nbsp &nbsp &nbsp 学号：19335151

# 实验要求

> 实验描述：表达式语义分析器的设计与实现
>
> 实验要求：
>
> * 使用**递归下降翻译法**或**LL(1)翻译法**实现高级编程语言的语义分析，将其翻译为**四元式格式**的中间语言，至少支持**算术表达式**的语义分析。
>
> - 算数表达式至少支持加减乘除以及括号操作，即（+，-，*，/，（））。
>
> 提交内容：
>
> 1. 实验报告，报告内容必须包括：
>
>    ​	• 翻译文法；
>
>    ​	• 若采用递归下降翻译法，须给出文法（至少实现算术表达式的文法）的子程序流程图，并在其上标注返回地址；
>
>    ​	• 给出一个算术表达式实例的分析表（表项内容参考实验三PPT P17）；
>
>    ​	• 运行结果展示；
>
>    ​	•以及其他必要内容
>
> 2. 语义分析源程序：source.c（源程序包）
>
> 3. 可执行文件
>
> 4. 程序测试文件：test.txt（实验输入，将测试案例写入程序的可没有此项）



# 实验思路

​	本次实验要求实现一个至少支持算术表达式的语义分析器，将其翻译为四元式格式的中间语言。要实现语义分析器，只需要基于语法分析器拓展，将表达式文法改写为翻译制导文法，加入动作符号指明在文法中执行语义翻译动作的时机以及需要执行的对应动作，同时使用一个语义栈辅助产生四元式。

## 翻译文法

对于语法分析器基于的LL1文法，修改为语义制导翻译文法如下：
$$
E \to TE_1\ \ \ (1)\\ E_1 \to \omega_0T\{GEQ(\omega_0)\}E_1\ (2)\ |\ \varepsilon \ (3)\\T \to FT_1\ \ \ (4) \\ T_1\to  \omega_1F\{GEQ(\omega_1)\}T_1\ (5)\ |\ \varepsilon \ (6)\\F \to I\{PUSH(I)\}\ (7) \ |\ (E)\ (8)
$$
分析表如下：

|       |  I   |  ω0  |  ω1  |  （  |  ）  |  #   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|  $E$  |  1   |      |      |  1   |      |      |
| $E_1$ |      |  2   |      |      |  3   |  3   |
|  $T$  |  4   |      |      |  4   |      |      |
| $T_1$ |      |  6   |  5   |      |  6   |  6   |
|  $F$  |  7   |      |      |  8   |      |      |



## 拓展实现

### 动作识别

在语法分析器中，将同优先级的运算符合并为一个集合（如：ω0指代 + - ...，ω1指代 / * ...）。而语法分析器则需要对每个运算符指定不同的四元式产生操作（如：GEQ{+}, GEQ{-}, GEQ{*}...），如何在不增加产生式的前提下，即保留原有的语法分析器实现，又能够对不同的运算符产生不同的产生式呢？其实很简单，只需要我们可以把运算符记录下来，在遇到动作符号时，将对应的运算符取出即可。

那么另一个问题就来了，如何保证运算符的顺序与动作符号能够保持一致对应呢？而且，如何记录这些元素呢，我们观察到在遇到并执行动作符号之前，要被处理（如：压栈、产生四元式）的元素已经在匹配语法时已经被移进丢失了。

为了解决上述问题，我额外添加了一个日志栈log，用于在语法分析执行移进动作前记录元素（括号与终止符不记录）。为什么这个日志栈可以解决提到的问题，因为日志栈的压栈发生在移进操作之前，也就是语法分析最后一次逆序压栈，此时必然压入一个带有动作符号的产生式，同时被移进元素与产生式中的动作符号正好对应，所以既解决了记录元素的问题，使用栈的数据结构，与语法分析栈一致，保证操作顺序的一致。

然后再修改语法分析器的分析主程序，使其可以识别动作符号。在识别到动作符号为压栈 $PUSH\{I\}$ 时，先到日志栈中取得栈顶元素，即为待压入元素。若为四元式产生动作，则需从日志栈中取得运算符，再从语义栈中取得元素产生四元式。

### 赋值处理

在语法分析器中，我将赋值符号视为一个简单的二元运算符处理，这在语法分析中是可行的，因为这也符合算术表达式的语法，但语义分析则涉及优先级的考虑。此处由于是实现简单的算术表达式，我就将赋值的处理推后到整个表达式的语义分析最后，这也符合算术表达式的逻辑，因为赋值运算的优先级总是最低，所以我设计的语义分析器先处理赋值运算符右边的子表达式后，将子表达式的中间结果，与语义栈的下一元素产生四元式。

基于这样的处理，我做了一个假设：一个算术表达式只能出现一个赋值运算符，若出现多个赋值运算符则会返回在一个算术表达式中重复赋值的错误，也符合算术表达式的逻辑。

### 负数处理

在上一次实验中，我实现了负数的识别与自增自减操作。在语义分析器中也同样实现该功能，此处定义负数（以-a为例）的四元式为（ -, a, _, t0），意为把-a写到中间结果t0中，自增的四元式为（ ++, a, _, t0），自减同理。但负号后可嵌套子表达式，通过语法分析器的递归检查同样可以得到子表达式计算的结果，因为日志栈的实现是分析器类内成员，所以递归的信息可以在栈中保留。



## 分析实例

分析实例：a - b / c ; 

| SYN[n]                                               | x                   | w    | op            | SEM[m] | log[l] | QT[q]           |
| ---------------------------------------------------- | ------------------- | ---- | ------------- | ------ | ------ | --------------- |
| #E                                                   | E                   | a    | （1）逆序压栈 |        |        |                 |
| #$E_1T$                                              | T                   | a    | （4）逆序压栈 |        |        |                 |
| #$E_1T_1F$                                           | F                   | a    | （7）逆序压栈 |        |        |                 |
| #$E_1T_1PUSH(I)I$                                    | I                   | a    | 移进          |        | a      |                 |
| #$E_1T_1PUSH(I)$                                     | PUSH(I)             | -    | push(a)       | a      |        |                 |
| #$E_1T_1$                                            | T1                  | -    | （6）逆序压栈 | a      |        |                 |
| #$E_1$                                               | E1                  | -    | （2）逆序压栈 | a      |        |                 |
| #$E_1\{GEQ(\omega_0)\}T\omega_0$                     | ω0                  | -    | 移进          | a      | -      |                 |
| #$E_1\{GEQ(\omega_0)\}T$                             | T                   | b    | （4）逆序压栈 | a      | -      |                 |
| #$E_1\{GEQ(\omega_0)\}T_1F$                          | F                   | b    | （7）逆序压栈 | a      | -      |                 |
| #$E_1\{GEQ(\omega_0)\}T_1PUSH(I)I$                   | I                   | b    | 移进          | a      | -b     |                 |
| #$E_1\{GEQ(\omega_0)\}T_1PUSH(I)$                    | PUSH(I)             | /    | push(b)       | ab     | -      |                 |
| #$E_1\{GEQ(\omega_0)\}T_1$                           | T1                  | /    | （5）逆序压栈 | ab     | -      |                 |
| #$E_1\{GEQ(\omega_0)\}T_1\{GEQ(\omega_1)\}F\omega_1$ | ω1                  | /    | 移进          | ab     | -/     |                 |
| #$E_1\{GEQ(\omega_0)\}T_1\{GEQ(\omega_1)\}F$         | F                   | c    | （7）逆序压栈 | ab     | -/     |                 |
| #$E_1\{GEQ(\omega_0)\}T_1\{GEQ(\omega_1)\}PUSH(I)I$  | I                   | c    | 移进          | ab     | -/c    |                 |
| #$E_1\{GEQ(\omega_0)\}T_1\{GEQ(\omega_1)\}PUSH(I)$   | PUSH(I)             | ;    | push(c)       | abc    | -/     |                 |
| #$E_1\{GEQ(\omega_0)\}T_1\{GEQ(\omega_1)\}$          | $\{GEQ(\omega_1)\}$ | ;    | $\{GEQ(/)\}$  | a t0   | -      | （/, b, c, t0） |
| #$E_1\{GEQ(\omega_0)\}T_1$                           | T_1                 | ;    | （6）逆序压栈 | a t0   | -      |                 |
| #$E_1\{GEQ(\omega_0)\}$                              | $\{GEQ(\omega_0)\}$ | ;    | $\{GEQ(-)\}$  | t1     |        | (-, a, t0, t1)  |
| #$E_1$                                               | $E_1$               | ;    | （3）逆序压栈 | t1     |        |                 |
| #                                                    | #                   | ;    | 分析结束      | t1     |        |                 |

可见日志栈的功能正确，语义分析器也确实可以产生正确的四元式。

# 具体实现

这次的实验基于之前的语法分析器进行拓展，主要依照实验思路中的拓展实现想法。其他实现均基于语法分析器没有大的改动。

## 词法分析拓展

由于之前语法分析器都是基于token串进行分析，而本次实验尚未实现符号表，为了增加四元式的可读性。在词法分析的过程中，将生成的token拓展为<variable, token>对，在生成四元式时使用对应的variable，而不是token。

## 动作识别

实现中将ω0的动作符号设置为‘b’，ω1的动作符号设置为'd'。

识别逻辑实现如下：

```c++
//判断是否为动作符号
if(islower(curr)){
    //识别到压语义栈操作
    if(curr == 'p'){
        string tk = log.top();
        log.pop();
        SEM.push(tk);
    }
    //识别到ω0动作符号操作
    else if(curr == 'b'){
        //从日志栈中取运算符
        string op = log.top();
        log.pop();
        //若为等号，只记录不产生四元式，推迟到最后产生
        if(op == "="){
            assign_flag++; 
            if(assign_flag > 1){
                cout << "Repeated Assignment!" << endl;
                return false;
            }
        }
        //四元式产生过程
        else{
            string a = SEM.top();
            SEM.pop();
            string b = SEM.top();
            SEM.pop();
            string res = "t" + to_string(cnt);
            SEM.push(res);
            cnt++;
            string qt = "( " + op + " " + a + " " + b + " " + res + " )";
            QT.push_back(qt);
        }
    }
    //识别到ω1动作符号操作
    else if(curr == 'd'){
        string op = log.top();
        log.pop();
        string a = SEM.top();
        SEM.pop();
        string b = SEM.top();
        SEM.pop();
        string res = "t" + to_string(cnt);
        SEM.push(res);
        cnt++;
        string qt = "( " + op + " " + a + " " + b + " " + res + " )";
        QT.push_back(qt);
    }
}
```

## 赋值处理

当语义分析器分析完整个表达式字符串后，即读到终止符后，必然在语义栈中留下一个待赋值的变量与子表达式的计算结果。具体实现如下：

```c++
else if(curr == '#'){
    if(token_arr[index].second != "57" && token_arr[index].second != "58"){
        cout << "Missing terminator!" << endl;
        return false;
    }
    //赋值处理
    else{
        if(assign_flag){
            string a = SEM.top();
            SEM.pop();
            string b = SEM.top();
            SEM.pop();
            string res = "( = " + a + " _ " + b + " )";
            QT.push_back(res);
            assign_flag = 0;
        }
        index++;
    }
}
```

## 负数识别

对于负数识别的实现，语义分析器中在移进过程中遇到负号，生成负数的四元式。具体实现如下：

```c++
//I终结符遇到负号
if(token_arr[index].second == "46"){
    //若负号后紧接常数或变量
    if(token_arr[index + 1].second == "03" || token_arr[index + 1].second == "00"){
        string a = token_arr[index + 1].first;
        string b = "t" + to_string(cnt++);
        //产生负数四元式
        string res = "( - " + a + " _ " + b + " )";
        QT.push_back(res);
        //中间结果压入日志栈，待push动作压入
        log.push(b);
        index += 2;
    }
    //若负号后接子表达式
    else if(token_arr[index + 1].second == "53"){
        int right = index + 1, left = index + 1;
        for( ; token_arr[right].second != "54" ; ++right){
            if(right == token_arr.size() - 1){
                cout << "Missing \')\'" << endl;
                return false;
            }
        }
        right++;
        vector<pair<string, string> > temp{&token_arr[left], &token_arr[right]};
        temp.push_back(make_pair(";", "58"));
        //子表达式正确
        if(check(temp)){
            //从语义栈中取出子表达式结果
            string a = SEM.top();
            SEM.pop();
            string b = "t" + to_string(cnt++);
            //产生负数四元式
            string res = "( - " + a + " _ " + b + " )";
            QT.push_back(res);
            //中间结果压入日志栈，待push动作压入
            log.push(b);
            index = right;
        }
        else{
            cout << "invaild sub-expression" << endl;
            return false;
        }
    }
    else{
        cout << "Invaild negative number!" << endl;
        return false;
    }
}
```

自增自减操作与负号后接常数或变量的处理逻辑类似，这里不再赘述。



# 实验结果

对于正确表达式，可以正确生成合法的四元式，且四元式的生成顺序符合逻辑顺序。

对第一个表达式：

1. 先计算++a的结果，将其存到t0；
2. 计算-2；
3. 计算括号内-2 * 1
4. 计算括号内++a + -2 * 1的结果
5. 计算a * (++a + -2 * 1)的结果 t4
6. 计算 t4 + 1结果 t5
7. 将t5 赋给 a.

四元式过程符合算术表达式运算顺序。

第二个表达式分析同理，这里不再赘述。

![1](D:\学\编译原理\lab3\1.png)

对于错误结果，在语法分析过程给出错误报告。

![2](D:\学\编译原理\lab3\2.png)



# 实验心得

